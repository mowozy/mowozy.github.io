<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript对象到原型链]]></title>
    <url>%2F2018%2F06%2F20%2FJavaScript%E5%AF%B9%E8%B1%A1%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[JavaScript对象到原型链对象（object）作为面向对象编程（OOP）的功能中心，既是对单个事物的抽象，也是一个封装了属性（property）和方法（method）的容器。JavaScript并不是典型的面向对象语言（C++，Java）一开始就有类（class）的概念，（class，ES6引进了这个关键字，但更多是语法糖）。JS通过构造函数和原型链来模拟类的功能，实现对象体系。 创建对象：构造函数（constructor）和new命令构造函数（constructor）JavaScript使用构造函数（constructor）作为对象的模板。构造函数是专门用来创建实例对象的函数，是对象的模板，描述对象的结构。 构造函数属于函数，但是有自己的特征和用法。 123var Vehicle = function () &#123; this.price = 1000;&#125;; 上面代码中，Vehicle就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。 构造函数的特点有两个。 函数体内部使用了this关键字，代表了所要生成的对象实例。 生成对象的时候，必须使用new命令。 new命令new命令的作用，就是执行构造函数，返回一个实例对象。 12345678var Vehicle = function (p) &#123; this.price = 1000; this.number = p;&#125;;var v = new Vehicle(123);v.price // 1000v.number //123 new命令执行了构造函数Vehical,生成了对象实例，并将它保存给v。v从构造函数中获得了price和接受参数的number属性。在new命令执行时，这里的this指代新生成的实例对象。 1234567var Vehicle = function ()&#123; this.price = 1000;&#125;;var v = Vehicle();v // undefinedprice // 1000 假如不使用new命令，则构造函数被作为普通函数调用，则这里的函数内this指向全局对象。这里v没有获得返回值变成了undefined，price则变成了全局变量.(如使用严格模式下，函数体内部的this不允许指向全局变量，此行为会报错) new命令的原理使用new命令时，构造函数执行下面步骤 创建一个空对象，作为将要返回的对象实例。 将这个空对象的原型，proto指向构造函数的prototype属性。 将这个空对象赋值给函数内部的this关键字。 开始执行构造函数内部的代码 原型链：_proto_属性 和prototype以及constructor属性面向对象编程很重要的一个方面，就是对象的继承。A 对象通过继承 B 对象，就能直接拥有 B 对象的所有属性和方法。这对于代码的复用是非常有用的。 __proto__对象的__proto__属性值就是对象所对应的原型对象prototype 12345var one = &#123;x: 1&#125;;var two = new Object();one.__proto__ === Object.prototype // truetwo.__proto__ === Object.prototype // trueone.toString === one.__proto__.toString // true 这里one是直接创建的字面量对象，two是使用Object本身构造函数创建的对象，他们都继承自Object的原型对象prototype，所以_proto_ 指向Object.prototype prototype大部分面向对象的编程语言，都是通过“类”（class）来实现对象的继承。JavaScript 语言的用函数模拟类，继承则是通过“原型对象”（prototype）。 因此，只有函数具有prototype属性，当一个函数被创建时自动添加，值是一个有constructor属性的对象。而一旦你把这个函数当作构造函数（constructor）调用（即通过new关键字调用），那么JS就会帮你创建该构造函数的实例，实例继承构造函数prototype的所有属性和方法（实例通过设置自己的__proto__指向承构造函数的prototype来实现这种继承）。 prototype的作用123456789101112function Cat(name, color) &#123; this.name = name; this.color = color; this.meow = function () &#123; console.log('喵喵'); &#125;;&#125;var cat1 = new Cat('大毛', '白色');var cat2 = new Cat('二毛', '黑色');cat1.meow === cat2.meow 使用构造函数构造实例的时候，会为每个实例重新创建属性和方法，但是同一个构造函数的多个实例之间，无法共享属性和方法，从而造成对系统资源的浪费。 使用原型对象prototype的作用在于原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。 123456789101112131415161718192021222324function Animal(name) &#123; this.name = name;&#125;Animal.prototype.color = 'white';var cat1 = new Animal('大毛');var cat2 = new Animal('二毛');cat1.color // 'white'cat2.color // 'white'//实例对象都共享了color属性Animal.prototype.color = 'yellow';cat1.color // "yellow"cat2.color // "yellow"//原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。cat1.color = 'black';cat1.color // 'black'cat2.color // "yellow"//实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。 constructor属性 prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。 由于constructor属性定义在prototype对象上面，意味着可以被所有实例对象继承。 12345678function P() &#123;&#125;P.prototype.constructor === P // truevar p = new P();p.constructor === P // truep.constructor === P.prototype.constructor // truep.hasOwnProperty('constructor') // false constructor属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的,并且可以取到这个构造函数来使用它。 1234567function F() &#123;&#125;;var f = new F();f.constructor === F // truevar f2 = new f.constructor();f2 instanceof F //true 原型链JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型…… 读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，则返回undefined。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。 原型继承总结]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown入门]]></title>
    <url>%2F2018%2F06%2F13%2FMarkdown%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Markdown入门1. Markdown简介 Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。 第一次意识到Markdown是在建立github项目的时候，然后发现各种项目里的作者也都使用其来编写文档，后来在简书上也看见使用Markdown写作。这次花一篇文章的功夫记录一下使用方法，也当做Blog的开头。 总的来说，Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。 优点 专注你的文字内容而不是排版样式，安心写作。 轻松的导出 HTML、PDF 和本身的 .md 文件。 纯文本内容，兼容所有的文本编辑器与字处理软件。 随时修改你的文章版本，不必像字处理软件生成若干文件版本导致混乱。 可读、直观、学习成本低。 官方文档 创始人 John Gruber 的 Markdown 语法说明 Markdown 中文版语法说明 2. Markdown语法简介标题Markdown中定义标题层级使用#号。 # 一级标题 ## 二级标题 ### 三级标题···共六级，#号后加一个空格 列表Markdown中的列表有些类似html，分成有序列表和无序列表。无序列表：列表项前加 *或-（空格） 1 * 1 2 * 2 3 * 3 有序列表：列表项前加1. 2. 3. ……（空格） 1 1. 1 2 2. 2 3 3. 3 引用Markdown中引用别处句子的格式在文本前加入 &gt; 例如这样 &gt;例如这样 图片和链接Markdown插入图片和链接的语法差不多，插入图片前加 ! 插入链接Mowzoy[Mowzoy](https://github.com/mowozy) 插入图片插入图片需要图床，写Blog需求，这里用github的图片引用示例 ![Markdown](https://github.com/mowozy/mowozy.github.io/raw/master/img/Markdown.png) (将github项目图片文件地址中的/blob/替换为/raw/即可访问图片文件) 粗体与斜体Markdown的粗体和斜体使用*号 粗体：双*包裹粗粗粗粗粗粗粗体 **粗粗粗粗粗粗粗体** 斜体：单*包裹斜斜斜斜斜斜斜体 *斜斜斜斜斜斜斜体* 表格Markdown的表格比较复杂，类似grid里用的那种分格方式 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 | Tables | Are | Cool ||----------------|:-------------:|------: |(此处写法控制左右居中)| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 分割线 分割线的语法只需要另起一行，连续输入三个星号 *** 即可。 3. 小结差不多到这里，基本的Markdown语法够用了，需要多多练习。本篇文章也是现学现用构筑的。更多的语法可以查阅Markdown 中文版语法说明就从现在开始用Markdown来写文啦！]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
